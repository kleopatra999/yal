yal
===

Yet Another Logger

### YAL задуман быть простым...очень простым

Возможности:

1. Сессии: вы можете создать(`YAL_CREATE()`) нужное кол-во сессий, и каждой из них задать свои параметры(путь/имя хранения логов, размер тома, лимит томов). Так же, присутствует макрос `YAL_CREATE2()`, который может использоваться для инициализации сущестрвующей переменной-сесии.
```cpp
struct type {
   type()
      :session(YAL_CREATE2("session1"))
   {}

   yal::session session;
};

...

int main() {
   yal::session session1(YAL_CREATE2("session1"));
   yal::session session2 = YAL_CREATE2("session2");
}
```
2. Ротация: при достижении томом указанного размера(третий аргумент для `YAL_CREATE(session_object, "session_name", 1024)`) - будет создан новый том. Если окажется так, что при записи какого-то сообщения будет превышен размер тома, то это сообщение будет записано в текущий том, и только после этого будет создан новый том. При перезапуске вашего приложения, если для какой-то конкретной сессии уже существуют логи - будет вычислен номер последнего тома, и создастся новый том, с номером на единицу больше.
3. Именование томов: к примеру, при создании сессии вы указали следующие значения: `YAL_CREATE(session1, "session1")`, тогда, именем объекта сессии будет `session1`, и префиксом томов будет 'session1'. Имена томов будут следующего формата: `session1-0000-21.10.2013-01.13.26`,`session1-0001-21.10.2013-01.13.26`,`session1-0002-21.10.2013-01.13.26`. Тут, следующее значение после имени тома - номер тома. Почему четыри цифры, спросите вы? - для корректной сортировки томов при использовании любого файлового менеджера. Почему именно четыре цифры? - при создании сессии используя `YAL_CREATE()`, четвертым аргументом передается лимит кол-ва томов, который, по умолчанию, установлен в значение `9999`(вот откуда четыре цифры). Таким образом, так как именование томов начинается с нуля, мы получим `10000` томов. В случае же, если в ходе работы программы кол-во томов превысит лимит(ну, не переставать же логировать, в самом деле!) - будет установлен новый лимит, который будет в десять раз больше предыдущего, и так далее.

### Использование

Основа YAL - класс `yal::logger`, который является потокобезопасным синглтоном. Таким образом в вашем приложении может существовать только одна копия YAL. Но это не проблема, у нас же в распоряжении есть возможность создать неограниченное кол-во сессий!

Первым делом, если вы не желаете хранить логи в текущей директории, вы должны вызвать `YAL_SET_ROOT_PATH()` и аргументом указать путь, который будет корневым каталогом логов. Использовать эту возможность можно только единожды, и прежде создания сессий.

Как уже было сказанно выше, сессии создаются использованием `YAL_CREATE()`, где вторым аргументом указывается имя сессии. В имени сессии так же можно указать относительный путь к каталогу в котором будут сохраняться тома. К примеру, вызвав `YAL_CREATE(session1, "session1/session1")`, в каталоге который был указан при помощи `YAL_SET_ROOT_PATH()` будет создан подкаталог 'session1', и в нем будут храниться логи.

Так же, в распоряжении пользователя доступен `YAL_FLUSH()`, который, принудительно сбросит буфера всех существующих сессий на диск.

Пример:
```cpp
#include <yal/yal.hpp>

int main() {
        YAL_SET_ROOT_PATH("/var/log/myapplication")
        YAL_CREATE(session1, "session1")
        YAL_CREATE(session2, "session2")
        
        ...
        
        YAL_FLUSH()
}
```

Объекты сессий создаваемые вызовом `YAL_CREATE()`, являются смарт-указателями(`std::shared_ptr<yal::detail::session>`). Таким образом, вы можете копировать эти объекты и передавать их в любые функции/методы, по значению. Сессия существует до тех пор, пока на нее хоть кто-то ссылается. По этому, вам не нужно следить за сессиями.

Логирование производится макросами `YAL_LOG_ERROR()`,`YAL_LOG_WARNING()`,`YAL_LOG_DEBUG()`,`YAL_LOG_INFO()`. Все четыре макроса в использовании абсолютно идентичны. Разница лишь в том, что записывается разный 'error level'.
Пример:
```cpp
YAL_LOG_INFO(session1, "%d-%s-%d", 1, "2", 3)
```

Тут, первый аргумент - объект сессии, второй - форматная строка, третий - список(произвольной длины) переменных.

Так же доступны следующие макросы: `YAL_GLOBAL_LOG_ERROR()`,`YAL_GLOBAL_LOG_WARNING()`,`YAL_GLOBAL_LOG_DEBUG()`,`YAL_GLOBAL_LOG_INFO()`. Отличие этих макросов от предыдущих в том, что сообщения логируемые при помощи этих макросов, будут записаны сразу во все существующие сессии в данный момент.

На самом деле, если заглянуть в исходники, вы сможете обнаружить что в качетве форматировщика вывода используется `boost::format`, поэтому вы можете в форматной строке использовать и `boost::format`-стиль.
Причина по которой используется `boost::format` а не fprintf - проста - типобезопасность, возможность использовать C++-типы, и возможность использовать пользовательские типы.

Пример записей в лог-файле для разных 'error level':
```
[21.10.2013-01.13.26][info   ][main.cpp:15][int main()]: 0000000000000000 -> 0000000000000000
[21.10.2013-01.13.26][debug  ][main.cpp:16][int main()]: 0000000000000000 -> 0000000000000000
[21.10.2013-01.13.26][warning][main.cpp:17][int main()]: 0000000000000000 -> 0000000000000000
[21.10.2013-01.13.26][error  ][main.cpp:18][int main()]: 0000000000000000 -> 0000000000000000
```

Описание дополнительных макросов:

1. `YAL_SESSION_FLUSH(log)` - флашит конкретную сессию.
2. `YAL_SESSION_SET_LEVEL(log, lvl)` - устанавливает 'error level. Позволяет отбросить логирование всех 'error level' которые имеют значение ниже указанного.
3. `YAL_SESSION_SET_BUFFER(log, size)` - устанавливает размер буфера ввода-вывода. (см. setvbuf())
4. `YAL_SESSION_SET_UNBUFFERED(log)` - указывает не использовать буферизацию ввода-вывода.
5. `YAL_SESSION_TO_TERM(log, flag, pref)` - указывает(если flag == true) производить вывод и на терминал. `pref` - префикс, используемый для идентифицирования вывода(терминал-то у нас один).
6. `YAL_SESSION_GET(var, name)` - получить объект сессии имея ее имя.
7. `YAL_SESSION_EXISTS(name)` - возвращает `true` если сессия с указанным именем существует, иначе `false`.

Еще один макрос являющийся частью приватной реализации - `YAL_MESSAGE_AS_STRING(...)`. Принимает форматную строку и произвольное кол-во аргументов. Возвращает `std::string`.
```cpp
std::cout << YAL_MESSAGE_AS_STRING("message") << std::endl;
std::cout << YAL_MESSAGE_AS_STRING("%s-%02d", "message", 2) << std::endl;
```
Вывод:
```
[main.cpp:9][int main()]: message
[main.cpp:9][int main()]: message-02
```
Т.е., этот макрос, в добавок к указанной пользователем информации, дополнит сформированную строку именем файла,номером строки, и именем функции, в которой этот макрос был использован.

Допустим, ваше приложение стало нереально стабильным, и вам более не нужно логировать такие 'error level' как info/debug. Для этого, вы можете повысить нижний 'error level' до уровня 'warning'. Но при этом, макросы `YAL_LOG_INFO()` и `YAL_LOG_DEBUG()` все равно будут "разворачиваться" в код и создавать некоторый оверхед. Чтоб этого не происходило, воспользуйтесь соответствующими макросами `YAL_DISABLE_INFO`,`YAL_DISABLE_DEBUG`,`YAL_DISABLE_WARNING`,`YAL_DISABLE_ERROR`. Просто добавьте нужные из них в опции компилятора.
Либо же вы можете полностью отключить логирование вашего приложения, добавив в опции компилятора `YAL_DISABLE_LOGGING`.

YAL зависит от boost.system и boost.filesystem.
