yal
===

Yet Another Logger

### YAL задуман быть простым. Очень простым.

Возможности:

1. Сессии: вы можете создать(`yal::logger::create()`) нужное кол-во сессий, и каждой из них задать свои параметры(путь/имя хранения логов, размер тома, лимит томов).
2. Ротация: при достижении томом указанного размера(второй аргумент для `yal::logger::create(..., 1024, ...)`) - будет создан новый том. Если окажется так, что при записи какого-то сообщения будет превышен размер тома, то это сообщение будет записано в текущий том, и только после этого будет создан новый том.
3. Именование томов: к примеру, при создании сессии вы указали следующие значения: `yal::logger::create("session1")`, тогда, префиксом томов будет `session1`. Имена томов будут следующего формата: `session1-0000-21.10.2013-01.13.26`,`session1-0001-21.10.2013-01.13.26`,`session1-0002-21.10.2013-01.13.26`. Тут, следующее значение после имени тома - номер тома. Почему четыри цифры, спросите вы? - для корректной сортировки томов при использовании любого файлового менеджера. Почему именно четыре цифры? - при создании сессии используя `yal::logger::create()`, третим аргументом передается лимит кол-ва томов, который, по умолчанию, установлен в значение `9999`(вот откуда четыре цифры). Таким образом, так как именование томов начинается с нуля, мы получим `10000` томов. В случае же, если в ходе работы программы кол-во томов превысит лимит(ну, не переставать же логировать, в самом деле!) - будет установлен новый лимит, который будет в десять раз больше предыдущего, и так далее.

### Использование

Основа YAL - класс `yal::logger`, который является потокобезопасным синглтоном. Таким образом в вашем приложении может существовать только одна копия YAL. Но это не проблема, у нас же в распоряжении есть возможность создать неограниченное кол-во сессий!

Первым делом, если вы не желаете хранить логи в текущей директории, вы должны вызвать `yal::logger::root_path()` и аргументом указать путь, который будет корневым каталогом логов. Использовать эту возможность можно только еднажды, и прежде создания сессий.

Как уже было сказанно выше, сессии создаются использованием `yal::logger::create()`, где, первым аргументом указывается имя сессии. В имени сессии так же можно указать относительный путь к каталогу в котором будут сохраняться тома. К примеру, вызвав `yal::logger::create("session1/session1")`, в каталоге который был указан при помощи `yal::logger::root_path()` будет создан подкаталог 'session1', и в нем будут храниться логи.

Так же, в распоряжении пользователя доступен метод `yal::logger::flush()`, который, принудительно сбросит буфера всех существующих сессий на диск.

Пример:
```cpp
#include <yal/yal.hpp>

int main() {
        yal::logger::root_path("/var/log/myapplication");
        auto session1 = yal::logger::create("session1");
        auto session2 = yal::logger::create("session2");
        
        ...
        
        yal::logger::flush();
}
```

Объекты сессий создаваемые вызовом `yal::logger::create()`, являются смарт-указателями(`std::shared_ptr<yal::detail::session>`). Таким образом, вы можете копировать эти объекты и передавать их в любые функции/методы, по значению. Сессия существует до тех пор, пока на нее хоть кто-то ссылается. По этому, вам не нужно следить за сессиями. Если же случилось так, что вам по какой-то причине нужно удалить сессию - вызовите метод `reset()`, и, после этого, у вас появится возможность создать одноименную сессию:
```cpp
#include <yal/yal.hpp>

int main() {
        yal::logger::root_path("/var/log/myapplication");
        auto session1 = yal::logger::create("session1");

        ...
        
        session1.reset();
        session1 = yal::logger::create("session1");
}
```

Логирование производится макросами `YAL_ERROR()`,`YAL_WARNING()`,`YAL_DEBUG()`,`YAL_INFO()`. Все четыре макроса в использовании абсолютно идентичны. Разница лишь в том, что записывается разный 'error level'.
Пример:
```cpp
YAL_INFO(session1, "%d-%s-%d", 1, "2", 3);
```

Тут, первый аргумент - объект сессии, второй - форматная строка, третий - список переменных.

На самом деле, если заглянуть в исходники, вы сможете обнаружить что в качетве форматировщика вывода используется `boost::format`. Но, почему в примерах используется fprintf-стиль? - спросите вы. Дело в том, что для логирования и имени функции в которой используется макрос, нам нужно и в форматную строку и в первый аргумент неявно подставить соответствующие значения. Таким образом, при использовании позиционных плейсхолдеров в `boost::format`-стиле, первый(`%1%`) плейсхолдер оказывается занят, что только вносит путаницу. (в будущем, думаю, исправлю это неудобство)
Причина по которой используется `boost::format` а не fprintf - проста - типобезопасность, возможность использовать C++-типы, и возможность использовать пользовательские типы.

Пример записей в лог-файле для разных 'error level':
```
[21.10.2013-01.13.26][info   ][main.cpp:15][int main()]: 0000000000000000 -> 0000000000000000
[21.10.2013-01.13.26][debug  ][main.cpp:16][int main()]: 0000000000000000 -> 0000000000000000
[21.10.2013-01.13.26][warning][main.cpp:17][int main()]: 0000000000000000 -> 0000000000000000
[21.10.2013-01.13.26][error  ][main.cpp:18][int main()]: 0000000000000000 -> 0000000000000000
```

Описание дополнительных макросов:

1. `YAL_FLUSH(log)` - флашит конкретную сессию.
2. `YAL_SET_LEVEL(log, lvl)` - устанавливает 'error level. Позволяет отбросить логирование всех 'error level' которые имеют значение ниже указанного.
3. `YAL_SET_BUFFER(log, size)` - устанавливает размер буфера ввода-вывода. (см. setvbuf())
4. `YAL_SET_UNBUFFERED(log)` - указывает не использовать буферизацию ввода-вывода.
5. `YAL_TO_TERM(log, flag, pref)` - указывает(если flag == true) производить вывод и на терминал. `pref` - префикс, используемый для идентифицирования вывода(терминал-то у нас один).

Еще один макрос являющийся частью приватной реализации - `YAL_MESSAGE_AS_STRING(...)`. Принимает форматную строку и произвольное кол-во аргументов. Возвращает `std::string`.
```cpp
std::cout << YAL_MESSAGE_AS_STRING("message") << std::endl;
std::cout << YAL_MESSAGE_AS_STRING("%s-%02d", "message", 2) << std::endl;
```
Вывод:
```
[main.cpp:9][int main()]: message
[main.cpp:9][int main()]: message-02
```
